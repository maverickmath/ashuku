#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright muflax <mail@muflax.com>, 2009
# License: GNU GPL 3 <http://www.gnu.org/copyleft/gpl.html>

import os.path, re, sys, unicodedata
from datetime import datetime, timedelta, time

try:
    import yaml
except ImportError:
    print("Error: Couldn't load PyYAML.")
    sys.exit(1)
try:
    from yaml import CLoader as Loader
    from yaml import CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

PROFILE = 0
if PROFILE:
    import cProfile as profile

def read_config(path):
    path = os.path.expanduser(path)
    if os.path.exists(path):
        f = open(path, "r")
        config = yaml.load(f, Loader=Loader)
    else:
        print("No config found. Creating %s for you. Modify to your liking." %
              path)
        f = open(path, "w")
        f.write('---\n'
                '# Each attribute must be of one of the following types:\n'
				'# - qualitive (range from -2 to +2)\n'
				'# - quantitive\n'
				'# - cumulative (like quantitive, but all daily values are added up)\n'
				'#\n'
				'# All quantitive types also take the optional property "unit". When given, it\n'
				'# will also be optional for input, so that "ashuku add weight 78" and\n'
				'# "ashuku add weight 78kg" are identical.\n'
				'# The value "time" is used for the format XhYmZs, as in 3h20m10s. When no unit\n'
				'# is given, then minutes are assumed.\n'
				'#\n'
				'# You can also specify an alias via "alias". The normal name will be used for\n'
				'# the output, but it may be inconvenient to type.\n'
				'\n'
				'attributes:\n'
				'    happiness:\n'
				'        type: qualitive\n'
				'    sleep:\n'
				'        type: cumulative\n'
				'        unit: time\n'
				'    weight:\n'
				'        type: quantitive\n'
				'        unit: kg\n'
				'    日本語:\n'
                '        type: cumulative\n'
				'        unit: time\n'
				'        alias: japanese\n'
                '\n'
                'settings:\n'
                '    path: ~/txt/ashuku.txt\n'
				'...')
        sys.exit(1)

    return config

def uni_len(s):
    "Returns the real lenght of a string wrt half-width and full-width."
    l = 0
    for c in s:
        if unicodedata.east_asian_width(c) == "W":
            l += 2
        else:
            l += 1
    return l

def show(data, attributes, args):
    days = 14
    # try to parse first argument as days
    if args:
        try:
            days = int(args[0])
            args = args[1:]
        except ValueError:
            pass
    
    # throw away all attributes we don't wanna show
    if args:
        attrs = list(attributes.keys())
        for attr in attrs:
            matches = False
            for f in args:
                try:    
                    if attr.startswith(f) or attributes[attr]["alias"].startswith(f):
                        matches = True
                except KeyError:
                    pass
            if not matches:
                del(attributes[attr])

    # print header
    header = " " * (uni_len("09-09-09") + 1)
    header2 = "-" * uni_len(header)
    for attr in sorted(attributes.keys()):
        header += " | " + attr
        header2 += "-+-" + "-" * uni_len(attr)
    print(header)
    print(header2)

    # print body
    table_data = parse_data(data, attributes, days)

def parse_data(data, attributes, days):
    table = {}
    today = datetime.today()
    shown_dates = [date for date in data if (today - date).days < days]
    time_re = re.compile("^((?P<hour>\d+)h)?((?P<min>\d+)m)?((?P<sec>\d+)s)?$")

    for date in sorted(shown_dates):
        # I'm honestly not sure if I should just keep the timezone as it is
        # or if I should try to adjust it. I'll keep it as-is for now.
        day = date.strftime("%Y/%m/%d")
        for attr in data[date]:
            if not attr in attributes:
                continue
            value = data[date][attr]
            try:
                td = table[day]
                if attributes[attr]["type"] == "cumulative":
                    try:
                        old_value = table[day][attr]
                    except KeyError:
                        old_value = 0
                    
                    try:
                        if attributes[attr]["unit"] == "time":
                            value = parse_time(time_re, value)
                    except KeyError:
                        pass
                    
                    value += old_value

                table[day][attr] = value
            except KeyError:
                try:
                    if attributes[attr]["unit"] == "time":
                        value = parse_time(time_re, value)
                except KeyError:
                    pass
                table[day] = {attr: value}

    return table

def parse_time(time_re, value):
    m = time_re.match(value)
    hour, min, sec = m.group("hour", "min", "sec")
    hour = int(hour or "0")
    min = int(min or "0")
    sec = int(sec or "0")
    return hour * 3600 + min * 60 + sec

def main(args):
    # Initialization #
    ##################
    config = read_config("~/.ashuku")
    try:
        attributes = config["attributes"]
        types = {"cumulative", "quantitive", "qualitive"}
        for attr in attributes:
            t = attributes[attr]["type"]
            assert t in types
        settings = config["settings"]
        
        data_path = os.path.expanduser(settings["path"])
    except (KeyError, AssertionError) as err:
        print("Error: Config incomplete: %s missing." % err)
        sys.exit(1)

    data_dir = os.path.dirname(data_path) 
    if not os.path.exists(data_dir):
        print("Warning: Directory %s doesn't exist. Creating it for you." %
              data_dir)
        os.mkdir(data_dir)
        
    if not os.path.exists(data_path):
        print("Warning: Data file %s doesn't exist. Creating it for you." %
              data_path)
    data = yaml.load(open(data_path, "r"), Loader=Loader)

    # Get the command #
    ###################
    if len(args) > 1:
        command = args[1]
    else:
        command = "show"

    if "add".startswith(command):
        add(data, attributes, args[2:])
        write_data(data)
    elif "correlate".startswith(command):
        correlate(data)
    elif "graph".startswith(command):
        graph(data, args[2:])
    elif "show".startswith(command):
        show(data, attributes, args[2:])
    elif "undo".startswith(command):
        undo(data)
        write_data(data)
    else:
        print("Error: No command %s." % command)
        sys.exit(1)

if __name__ == "__main__":
    if PROFILE:
        profile.run("main(sys.argv)")
    else:
        main(sys.argv)
