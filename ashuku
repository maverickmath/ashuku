#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright muflax <mail@muflax.com>, 2009
# License: GNU GPL 3 <http://www.gnu.org/copyleft/gpl.html>

import os.path, re, sys, unicodedata
from datetime import datetime, timedelta, time

try:
    import yaml
except ImportError:
    print("Error: Couldn't load PyYAML.")
    sys.exit(1)
try:
    from yaml import CLoader as Loader
    from yaml import CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

PROFILE = 0
if PROFILE:
    import cProfile as profile
    import pstats

class Ashuku:
    # regex to match the time representation in the data
    time_re = re.compile("^((?P<hour>\d+)h)?((?P<min>\d+)m)?((?P<sec>\d+)s)?$")
    # all possible attribute types
    types = {"cumulative", "quantitive", "qualitative"}
    # date format, must be unique for every day (otherwise arbitrary)
    date_fmt = "%Y/%m/%d"
    # what units to use when showing time
    time_units = {"hour": "h", "min": "m", "sec": "s"}
    
    # cached lengths
    length = {}
    # cached date
    today = datetime.today()

    def __init__(self, config_path):
        config = self.read_config(config_path)
        try:
            self.attributes = config["attributes"]
            for attr in self.attributes:
                t = self.attributes[attr]["type"]
                assert t in Ashuku.types
            self.units = self.parse_units()
            self.settings = config["settings"]
            
            data_path = os.path.expanduser(self.settings["path"])
        except (KeyError, AssertionError) as err:
            print("Error: Config incomplete: %s missing." % err)
            sys.exit(1)

        data_dir = os.path.dirname(data_path) 
        if not os.path.exists(data_dir):
            print("Warning: Directory %s doesn't exist. Creating it for you." %
                  data_dir)
            os.mkdir(data_dir)
            
        if not os.path.exists(data_path):
            print("Warning: Data file %s doesn't exist. Creating it for you." %
                  data_path)
        self.data = yaml.load(open(data_path, "r"), Loader=Loader)

    def parse_command(self, args):
        if len(args) > 1:
            command = args[1]
        else:
            command = "show"

        if "add".startswith(command):
            self.add(args[2:])
            self.write_data()
        elif "correlate".startswith(command):
            self.correlate()
        elif "graph".startswith(command):
            self.graph(args[2:])
        elif "show".startswith(command):
            self.show(args[2:])
        elif "undo".startswith(command):
            self.undo()
            self.write_data()
        else:
            print("Error: No command %s." % command)
            sys.exit(1)

    def read_config(self, path):
        path = os.path.expanduser(path)
        if os.path.exists(path):
            f = open(path, "r")
            config = yaml.load(f, Loader=Loader)
        else:
            print("No config found. Creating %s for you. Modify to your liking." %
                  path)
            f = open(path, "w")
            f.write('---\n'
                    '# Each attribute must be of one of the following types:\n'
                    '# - qualitative (range from -2 to +2)\n'
                    '# - quantitive\n'
                    '# - cumulative (like quantitive, but all daily values are added up)\n'
                    '#\n'
                    '# All quantitive types also take the optional property "unit". When given, it\n'
                    '# will also be optional for input, so that "ashuku add weight 78" and\n'
                    '# "ashuku add weight 78kg" are identical.\n'
                    '# The value "time" is used for the format XhYmZs, as in 3h20m10s. When no unit\n'
                    '# is given, then minutes are assumed.\n'
                    '#\n'
                    '# You can also specify an alias via "alias". The normal name will be used for\n'
                    '# the output, but it may be inconvenient to type.\n'
                    '\n'
                    'attributes:\n'
                    '    happiness:\n'
                    '        type: qualitative\n'
                    '    sleep:\n'
                    '        type: cumulative\n'
                    '        unit: time\n'
                    '    weight:\n'
                    '        type: quantitive\n'
                    '        unit: kg\n'
                    '    日本語:\n'
                    '        type: cumulative\n'
                    '        unit: time\n'
                    '        alias: japanese\n'
                    '\n'
                    'settings:\n'
                    '    path: ~/txt/ashuku.txt\n'
                    '...')
            sys.exit(1)

        return config

    def uni_len(self, s):
        "Returns the real lenght of a string wrt half-width and full-width."
        try:
            l = Ashuku.length[s]
        except KeyError:
            l = 0
            for c in s:
                if unicodedata.east_asian_width(c) == "W":
                    l += 2
                else:
                    l += 1
            Ashuku.length[s] = l
        return l

    def show(self, args):
        # try to parse first argument as days
        try:
            days = int(args[0])
            args = args[1:]
        except (ValueError, IndexError):
            days = 14
        
        # throw away all attributes we don't wanna show
        self.filter_attributes(args)
        
        # nothing to show
        if not self.attributes:
            return

        # commence building table!
        keys = sorted(self.attributes.keys())
        table_data = self.parse_data(days)
        col_width = self.parse_col_width(table_data, keys)

        # print header
        header = " " * (self.uni_len(Ashuku.today.strftime(Ashuku.date_fmt)) + 1)
        header_div = "-" * self.uni_len(header)
        for key in keys:
            # string.center is not used because it doesn't understand
            # full-width characters
            key_width = self.uni_len(key)
            header += " | " + (" " * (col_width[key] - key_width)) + key
            header_div += "-+-" + ("-" * col_width[key])
        print(header)
        print(header_div)

        # print body
        for day in sorted(table_data):
            line = " " + day
            for key in keys:
                line += " | "
                try:
                    value = table_data[day][key]
                    if self.attributes[key]["type"] == "qualitative":
                        line += "{:+d}".format(value)
                    else:
                        if self.units[key] == "time":
                            str = self.format_time(value)
                        else:
                            str = "{}{}".format(value, self.units[key])
                        line += " " * (col_width[key] - self.uni_len(str)) + str
                except KeyError:
                    line += " " * col_width[key]
            print(line)

    def filter_attributes(self, args):
        if args:
            attrs = list(self.attributes.keys())
            for attr in attrs:
                matches = False
                for f in args:
                    try:    
                        if (attr.startswith(f) 
                            or self.attributes[attr]["alias"].startswith(f)):
                            matches = True
                            break
                    except KeyError:
                        pass
                if not matches:
                    del(self.attributes[attr])

    def parse_col_width(self, table_data, keys):
        col_width = {}
        for key in keys:
            if self.attributes[key]["type"] == "qualitative":
                col_width[key] = max(2, self.uni_len(key))
            else:
                widths = [0]
                for day in table_data:
                    try:
                        if self.units[key] == "time":
                            v = table_data[day][key]
                            str = self.format_time(v)
                        else:
                            str = "{}{}".format(table_data[day][key], 
                                                self.units[key])
                        widths.append(self.uni_len(str))
                    except KeyError:
                        pass

                col_width[key] = max(max(widths), self.uni_len(key))
        return col_width

    def parse_units(self):
        units = {}
        for attr in self.attributes:
            try:
                units[attr] = self.attributes[attr]["unit"]
            except KeyError:
                units[attr] = ""
        return units

    def parse_data(self, days):
        table = {}
        shown_dates = [date for date in self.data if (Ashuku.today - date).days < days]

        for date in sorted(shown_dates):              
            # I'm honestly not sure if I should just keep the timezone as it is
            # or if I should try to adjust it. I'll keep it as-is for now.
            day = date.strftime(Ashuku.date_fmt)
            for attr in self.data[date]:
                if not attr in self.attributes:
                    continue
                value = self.data[date][attr]
                try:
                    td = table[day]
                    if self.attributes[attr]["type"] == "cumulative":
                        try:
                            old_value = table[day][attr]
                        except KeyError:
                            old_value = 0
                        
                        try:
                            if self.attributes[attr]["unit"] == "time":
                                value = self.parse_time(value)
                        except KeyError:
                            pass
                        
                        value += old_value

                    table[day][attr] = value
                except KeyError:
                    try:
                        if self.attributes[attr]["unit"] == "time":
                            value = self.parse_time(value)
                    except KeyError:
                        pass
                    table[day] = {attr: value}

        return table

    def parse_time(self, value):
        m = Ashuku.time_re.match(value)
        hour, min, sec = m.group("hour", "min", "sec")
        hour = int(hour or "0")
        min = int(min or "0")
        sec = int(sec or "0")
        return hour * 3600 + min * 60 + sec
                            
    def format_time(self, value):
        s = value % 60
        m = value // 60 % 60
        h = value // (60 * 60)
        str = ""
        if h:
            str += "{}{}".format(h, Ashuku.time_units["hour"]) 
        if m:
            str += "{}{}".format(m, Ashuku.time_units["min"]) 
        if s:
            str += "{}{}".format(s, Ashuku.time_units["sec"]) 
        return str

def main(args):
    A = Ashuku("~/.ashuku")
    A.parse_command(args)

if __name__ == "__main__":
    if PROFILE:
        profile.run("main(sys.argv)", "profile.log")
        p = pstats.Stats("profile.log")
        p.sort_stats("time").print_stats(.5)
    else:
        main(sys.argv)
