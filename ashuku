#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright muflax <mail@muflax.com>, 2009
# License: GNU GPL 3 <http://www.gnu.org/copyleft/gpl.html>

import os.path, re, sys, unicodedata
from datetime import datetime, timedelta, time

try:
    import yaml
except ImportError:
    print("Error: Couldn't load PyYAML.")
    sys.exit(1)
try:
    from yaml import CLoader as Loader
    from yaml import CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

PROFILE = 0
if PROFILE:
    import cProfile as profile

class Ashuku:
    length = {}
    time_re = re.compile("^((?P<hour>\d+)h)?((?P<min>\d+)m)?((?P<sec>\d+)s)?$")
    types = {"cumulative", "quantitive", "qualitive"}

    def __init__(self, config_path):
        config = self.read_config(config_path)
        try:
            self.attributes = config["attributes"]
            for attr in self.attributes:
                t = self.attributes[attr]["type"]
                assert t in Ashuku.types
            self.settings = config["settings"]
            
            data_path = os.path.expanduser(self.settings["path"])
        except (KeyError, AssertionError) as err:
            print("Error: Config incomplete: %s missing." % err)
            sys.exit(1)

        data_dir = os.path.dirname(data_path) 
        if not os.path.exists(data_dir):
            print("Warning: Directory %s doesn't exist. Creating it for you." %
                  data_dir)
            os.mkdir(data_dir)
            
        if not os.path.exists(data_path):
            print("Warning: Data file %s doesn't exist. Creating it for you." %
                  data_path)
        self.data = yaml.load(open(data_path, "r"), Loader=Loader)

    def parse_command(self, args):
        if len(args) > 1:
            command = args[1]
        else:
            command = "show"

        if "add".startswith(command):
            self.add(args[2:])
            self.write_data()
        elif "correlate".startswith(command):
            self.correlate()
        elif "graph".startswith(command):
            self.graph(args[2:])
        elif "show".startswith(command):
            self.show(args[2:])
        elif "undo".startswith(command):
            self.undo()
            self.write_data()
        else:
            print("Error: No command %s." % command)
            sys.exit(1)

    def read_config(self, path):
        path = os.path.expanduser(path)
        if os.path.exists(path):
            f = open(path, "r")
            config = yaml.load(f, Loader=Loader)
        else:
            print("No config found. Creating %s for you. Modify to your liking." %
                  path)
            f = open(path, "w")
            f.write('---\n'
                    '# Each attribute must be of one of the following types:\n'
                    '# - qualitive (range from -2 to +2)\n'
                    '# - quantitive\n'
                    '# - cumulative (like quantitive, but all daily values are added up)\n'
                    '#\n'
                    '# All quantitive types also take the optional property "unit". When given, it\n'
                    '# will also be optional for input, so that "ashuku add weight 78" and\n'
                    '# "ashuku add weight 78kg" are identical.\n'
                    '# The value "time" is used for the format XhYmZs, as in 3h20m10s. When no unit\n'
                    '# is given, then minutes are assumed.\n'
                    '#\n'
                    '# You can also specify an alias via "alias". The normal name will be used for\n'
                    '# the output, but it may be inconvenient to type.\n'
                    '\n'
                    'attributes:\n'
                    '    happiness:\n'
                    '        type: qualitive\n'
                    '    sleep:\n'
                    '        type: cumulative\n'
                    '        unit: time\n'
                    '    weight:\n'
                    '        type: quantitive\n'
                    '        unit: kg\n'
                    '    日本語:\n'
                    '        type: cumulative\n'
                    '        unit: time\n'
                    '        alias: japanese\n'
                    '\n'
                    'settings:\n'
                    '    path: ~/txt/ashuku.txt\n'
                    '...')
            sys.exit(1)

        return config

    def uni_len(self, s):
        "Returns the real lenght of a string wrt half-width and full-width."
        try:
            l = Ashuku.length[s]
        except KeyError:
            l = 0
            for c in s:
                if unicodedata.east_asian_width(c) == "W":
                    l += 2
                else:
                    l += 1
            Ashuku.length[s] = l
        return l

    def show(self, args):
        days = 14
        # try to parse first argument as days
        if args:
            try:
                days = int(args[0])
                args = args[1:]
            except ValueError:
                pass
        
        # throw away all attributes we don't wanna show
        if args:
            attrs = list(self.attributes.keys())
            for attr in attrs:
                matches = False
                for f in args:
                    try:    
                        if attr.startswith(f) or self.attributes[attr]["alias"].startswith(f):
                            matches = True
                            break
                    except KeyError:
                        pass
                if not matches:
                    del(self.attributes[attr])

        # print header
        header = " " * (self.uni_len("09-09-09") + 1)
        header2 = "-" * self.uni_len(header)
        for attr in sorted(self.attributes.keys()):
            header += " | " + attr
            header2 += "-+-" + "-" * self.uni_len(attr)
        print(header)
        print(header2)

        # print body
        table_data = self.parse_data(days)

    def parse_data(self, days):
        table = {}
        today = datetime.today()
        shown_dates = [date for date in self.data if (today - date).days < days]

        for date in sorted(shown_dates):
            # I'm honestly not sure if I should just keep the timezone as it is
            # or if I should try to adjust it. I'll keep it as-is for now.
            day = date.strftime("%Y/%m/%d")
            for attr in self.data[date]:
                if not attr in self.attributes:
                    continue
                value = self.data[date][attr]
                try:
                    td = table[day]
                    if self.attributes[attr]["type"] == "cumulative":
                        try:
                            old_value = table[day][attr]
                        except KeyError:
                            old_value = 0
                        
                        try:
                            if self.attributes[attr]["unit"] == "time":
                                value = self.parse_time(value)
                        except KeyError:
                            pass
                        
                        value += old_value

                    table[day][attr] = value
                except KeyError:
                    try:
                        if self.attributes[attr]["unit"] == "time":
                            value = self.parse_time(value)
                    except KeyError:
                        pass
                    table[day] = {attr: value}

        return table

    def parse_time(self, value):
        m = Ashuku.time_re.match(value)
        hour, min, sec = m.group("hour", "min", "sec")
        hour = int(hour or "0")
        min = int(min or "0")
        sec = int(sec or "0")
        return hour * 3600 + min * 60 + sec

def main(args):
    A = Ashuku("~/.ashuku")
    A.parse_command(args)

if __name__ == "__main__":
    if PROFILE:
        profile.run("main(sys.argv)")
    else:
        main(sys.argv)
